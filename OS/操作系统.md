# 1

1. 操作系统的特征：并发、共享、虚拟、异步

2. OS的发展与分类

    1. 手工操作阶段

    2. 批处理阶段

        1. 单道批处理系统

        2. 多道批处理系统

    3. 分时操作系统

    4. 实时操作系统

        1. 硬实时系统

        2. 软实时系统

    5. 网络操作系统

    6. 分布式操作系统

    7. 个人计算机操作系统

3. OS的运行机制和体系结构

    1. 指令：特权指令和非特权指令

    2. 两种处理器状态：用程序状态字寄存器（PSW）中的某个标志位表示

        1. 用户态（目态）：CPU只能执行非特权指令

        2. 核心态（管态）：都可以执行

    3. 两种程序

        1. 内核程序：核心态执行

        2. 应用程序：用户态执行

    4. 内核：计算机上配置的底层软件，OS最基本、最核心的部分

        1. 时钟管理

        2. 中断处理

        3. 原语：具有原子性，不可中断；调用频繁；最底层、最接近硬件的部分

        4. 对系统资源进行管理的功能

            1. 进程管理

            2. 存储器管理

            3. 设备管理

    5. 体系结构：大内核、微内核

4. 中断和异常（内中断）

    1. 本质：发生中断，意味着需要操作系统介入，CPU进入核心态，开展管理工作

    2. 内中断：信号来自CPU内部；外中断：信号来自CPU外部（信号来源不同）

5. 系统调用

# 2

## 2.1

1. 进程：程序段、数据段、PCB（processing control block）程序控制块

    1. 创建进程：创建进程实体中的PCB，PCB是进程存在的唯一标志

    2. 操作系统通过PCB来管理进程

2. PCB

    1. 进程的组成：进程描述信息、进程控制和管理信息、资源分配清单、处理机相关信息

    2. 进程的组织：链接方式、索引方式

    3. 进程的特征：动态性、并发性、独立性、异步性、结构性

3. 进程的状态与转换

    1. 状态：
    
        1. 运行态：CPU、其他所需资源均到位
        
        2. 就绪态：没有空闲CPU、其他资源到位
        
        3. 阻塞态：等待其他资源到位
        
        4. 创建态
        
        5. 终止态

    2. 状态转换

        1. 就绪态 -> 运行态：进程被调度

        2. 运行态 -> 就绪态：时间片到或CPU被其他进程抢占

        3. 运行态 -> 阻塞态：等待系统资源分配或等待某事件发生（主动行为）

        4. 阻塞态 -> 就绪态：资源分配到位，等待事件发生（被动行为）

4. 进程控制

    1. 用原语实现进程控制：采用开、关中断指令实现；运行在核心态

    2. 相关原语：进程创建、终止、阻塞、唤醒、切换

5. 进程通信

    1. 进程通信：进程之间的信息交换

    2. 各进程拥有相互独立的内存地址空间

    3. 进程通信

        1. 共享存储

            1. 通过共享空间实现，两个进程对共享空间的访问必须是互斥的

            2. 共享存储：基于数据结构的共享、基于存储区的共享

        2. 管道通信

            1. 管道pipe：用于连接读写进程的一个共享文件

            2. 半双工通信，需要两个管道实现双向通信

            3. 各进程互斥地访问管道

            4. 没写满，不能读；没读空，不能写；写满阻塞待读空

            5. 读进程最多只能有一个

        3. 消息传递

            1. 以格式化的消息为单位进行数据交换，包括消息头、消息体

            2. 可以直接通信、间接通信

6. 线程

    1. 线程是一个基本的CPU执行单元，也是程序执行流的最小单位

        1. 线程是处理机调度的单位，进程是资源分配的单位

        2. 有用户级线程、内核级线程

    2. 多线程模型：多对一、一对一、多对多

## 2.2 调度

1. 高级调度（作业调度）：从外存上处于后备队列的作业中挑选一个作业，分配资源，建立进程（建立PCB），获得竞争处理机的权利（后备队列（外存） -> 内存）

2. 引入虚拟存储，提高内存利用率和系统吞吐量，可以将进程挂起（调到外存等待，但PCB不会被调到外存）

3. 中级调度（内存调度）：决定将哪个挂起的进程重新调入内存，调用比高级调用更高（挂起队列（外存） -> 内存）

4. 就绪挂起、阻塞挂起

5. 挂起时：进程被调到外存、阻塞时：进程还在内存中

6. 低级调度（进程调度）：从就绪队列中选择一个进程分配处理机（就绪队列（内存） -> 处理机）

7. 进程调度，可以主动放弃、被动放弃

8. 不能进行进程调度：

    1. 处理中

    2. 进程在系统内核程序临界区中，普通临界区可以进行调度

    3. 原子操作中

9. 进程调度和切换的区别

    1. 切换时需要保存和恢复各种数据

    2. 进程的调度和切换是有代价的

10. 有非抢占式、抢占式

11. 评价指标

    1. CPU利用

    2. 系统吞吐量

    3. 周转时间（完成时间 - 提交时间）

    4. 带权周转时间（周转时间 / 运行时间）

    5. 等待时间（周转时间 - 运行时间 - I/O操作时间）

    6. 响应时间

    7. 响应比 = （等待时间 + 要求服务时间） / 要求服务时间

12. 调度算法

    1. 先来先服务 FCFS

    2. 短作业优先 SJF：当前已到达且运行时间最短的作业

    3. 抢占式短作业优先 SRTN

    4. 高响应比优先 HRRN

13. 调度算法

    1. 时间片轮转 
    
        1. 更注重响应时间

    2. 优先级调度

        1. 抢占式、非抢占式

        2. 可能数字大的优先级高，也可能小的

        3. 静态优先级、动态优先级

    3. 多级反馈队列

        1. 用完一个时间片未执行完，放入下一级队列

        2. 被抢占，回到该级队列的队尾

        3. 已经在最后一级队列，则回到队尾

## 2.3 进程同步、进程互斥

1. 并发性带来了异步性，需要通过进程同步来解决异步问题

2. 进程互斥：同一时间只允许一个进程访问临界资源

    1. 包括四部分：进入区、临界区、退出区、剩余区

    2. 空闲让进、忙则等待、有限等待、让权等待

3. 进程互斥的软件实现

    1. 单标志法

    2. 双标志先检查法

    3. 双标志后检查法

    4. Peterson算法

4. 进程互斥的硬件实现

    1. 中断屏蔽

    2. TestAndSet指令（TS指令）= TestAndSetLock指令（TSL指令）

    3. Swap指令

5. 信号量机制

    1. 整型信号量：初始化、P操作、V操作

    2. 记录型信号量：可以阻塞和唤醒进程

6. 信号量实现进程同步和进程互斥

    1. 进程同步：初始化为S = 0，“前操作”之后先V(S)，“后操作”之前P(S)

    2. 进程互斥：初始化为S = 1，临界区之前先P(S)，临界区之后V(S)

    3. 实现前驱关系：为每一对前驱关系各设置一个同步变量，先V后P

7. 生产者、消费者问题

    1. 消费者需要等待生产者生产；生产者需要等待消费者消费，存在两对同步关系，需要两个同步信号量

    2. 生产、消费互斥

    3. 先同步再互斥，否则会发生死锁

    4. 生产者、消费者共享一个缓冲区

8. 多生产者、多消费者问题：从“事件”角度来分析前后关系

9. 吸烟者问题：单生产者多消费者

10. 读者-写者问题

    1. 可同时读

    2. 只允许一个写者

    3. 完成写之前不允许读

    4. 写前应让读者退出

    5. 对count变量的检查和赋值不能一气呵成，需要使用互斥信号量

11. 哲学家进餐问题

    1. 进程之间只存在互斥关系

    2. 关键在于解决死锁问题

12. 管程：高级同步机制

    1. 组成部分：共享数据结构、对数据结构进行操作的一组过程、设置初始值的语句、名字

    2. 基本特征：管程数据只能被管程过程访问、进程只能通过管程的过程来访问共享数据、每次仅允许一个进程执行某个管程过程

## 2.4 死锁

1. 概念

    1. 死锁、饥饿、死循环

        1. 死锁：循环等待对方手里的资源，至少有两个以上的进程同时发生死锁

        2. 饥饿：进程长时间得不到想要的资源，无法继续，可能只有一个进程发生饥饿

        3. 死循环：代码逻辑

    2. 必要条件

        1. 互斥条件

        2. 不剥夺条件

        3. 请求和保持条件

        4. 循环等待条件

    3. 什么时候会发生死锁

        1. 对系统资源的竞争

        2. 进程推进顺序非法

        3. 信号量使用不当

    4. 处理策略

        1. 预防死锁

        2. 避免死锁

        4. 死锁的检测和解除

2. 预防死锁

    1. 破坏互斥条件，如SPOOLing技术

    2. 破坏不剥夺条件：进程主动放弃资源或操作系统剥夺调度，但实现复杂

    3. 破坏请求和保持条件

        1. 静态分配方法：申请完全部资源再开始运行（资源利用率低，可能导致某些进程饥饿）

    4. 破坏循环等待条件

        1. 顺序资源分配方法：按编号递增顺序请求资源

3. 避免死锁

    1. 安全序列：按该序列分配资源，每个进程都能顺利完成

    2. 安全状态，一定不会发生死锁，不安全状态，可能发生死锁；不安全状态未必发生死锁，发生死锁，一定是不安全状态

    3. 银行家算法核心思想：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态

4. 处理策略

    1. 检测：使用资源分配图记录资源，如果不能消除全部的边，则发生了死锁

    2. 解除：资源剥夺法（挂起进程）、撤销进程法（终止进程）、进程回退法

# 3

## 3.1 内存

1. 装入方式：绝对装入、静态重定位、动态重定位

2. 链接方式：静态链接、装入时动态链接、运行时动态链接

3. 内存管理

    1. 内存空间的分配与回收

    2. 对内存空间进行扩充

    3. 完成逻辑地址与物理地址的转换 -> 三种装入方式

    4. 内存保护：

        1. 设置一对上、下限寄存器

        2. 采用重定位寄存器和界地址寄存器进行越界检查

4. 覆盖与交换

    1. 覆盖技术

        1. 解决程序大小超过物理内存总和的问题

        2. 内存分为一个“固定区”和若干个“覆盖区”，常用部分放在“固定区”，不常用部分放在“覆盖区”，需要时调入

        3. 由程序员声明覆盖结构
    
    2. 交换技术

        1. 中级调度（内存调度）

        2. 内存紧张时，换出某些进程，在换入某些进程

        3. 磁盘分文件区和对换区，换出的进程放在对换区

    3. 覆盖在同一进程中完成，交换在不同进程之间完成

5. 连续分配：为进程分配连续的内存空间

    1. 单一连续分配：内存分系统区和用户区，无外部碎片，有内部碎片

    2. 固定分区分配：分区大小可以相等、可以不等；需要分区说明表，无外部碎片，有内部碎片

    3. 动态分区分配：根据进程的大小动态地建立分区

        1. 记录内存使用：空闲分区表、空闲分区链

        2. 没有内部碎片，有外部碎片，可通过紧凑技术解决外部碎片

        3. 回收内存分区，可以合并要合并

6. 动态分区分配算法

    1. 首次适应算法：空闲分区按地址增序排列，找到第一个能满足大小的空闲分区

    2. 最佳适应算法：空闲分区按容量递增排序，优先使用更小的空闲分区；会留下越来越小的碎片

    3. 最坏适应算法：空闲分区按容量递减排序，优先使用更大的空闲分区，大分区会被越分越小

    4. 临近适应算法：每次都从上次查找结束的位置开始检索，空闲分区可以按递增的顺序排列，找到第一个满足要求的分区

7. 基本分页存储管理

    1. 将内存空间分为大小相等的分区：页框、页帧、内存页、物理块 

    2. 将用户进程的地址空间也分为与页框大小相等的区域，称为“页”或“页面”

    3. 操作系统以页框为单位为各个进程分配内存空间，进程的页面与内存的页框一一对应

    4. 如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2^K个内存单元

    5. 如果有M位表示“页号”，则说明该系统中，一个进程最多允许有2^M个页面

    6. 物理地址 = 页面始址 + 页内偏移量

    7. 操作系统要为每个进程建立一张页表，页面记录进程页面和实际存放的内存块之间的对应关系

8. 基本地址变换机构

    1. 页表寄存器：存放页表起始地址、页表长度

    2. 根据逻辑地址算出页号、页内偏移量

    3. 需要访问两次内存，一次查页表、一次访问目标内存单元

    4. 页式管理中地址是一维的 

9. 具有快表的地址变换机构

    1. 时间局部性、空间局部性

    2. 快表：联想寄存器（TLB），访问速度比内存快，用来存放当前访问的若干页表项

    3. 快表命中，只需一次访存；否则需要两次

10. 两级页表

    1. 建立页目录表

    2. 各级页表的大小不能超过一个页面

    3. N级页表需要N + 1次访存

11. 基本分段存储管理

    1. 按照程序自身的逻辑关系划分为若干个段，从0开始编址

    2. 段表：段号 + 段长 + 基址

    3. 分段时段长不固定，分页时页长固定；分页对用户不可见，分段对用户可见

    4. 分段的用户进程地址空间是二维的

    5. 分段比分页更容易实现信息的共享和保护

    6. 可重入代码：不能被修改的代码

12. 段页式管理方式

    1. 分段、分页优缺点

        |    | 优点 | 缺点 |
        | :---: | :---: | :---: |
        | 分页管理 | 内存空间利用率高，不会产生外部碎片，只有少量页内碎片 | 不方便按照逻辑模块实现信息的共享和保护 |
        |分段管理|方便实现信息的共享和保护|会产生外部碎片；段长过大时分配连续空间不方便|

    2. 段页式管理：先分段，再分页

        1. 段号的位数决定可以分几个段

        2. 页号的位数决定每个段最多可以有几页

        3. 页内偏移量决定了页面大小、内存块大小

    3. 逻辑地址 = 段号 + 页号+ 页内偏移量

    4. 需要三次访存：查段表、查页表、访问目标单元，引入快表仅需一次访存

## 3.2 虚拟内存

1. 传统存储管理方式

    1. 特征：一次性装入内存才能开始运行，大作业无法运行、多道程序并发度下降

    2. 驻留性：作业被装入后，一直驻留内存

2. 局部性原理

    1. 时间局部性：可能频繁访问同一指令

    2. 空间局部性：可能访问附近指令

    3. 高速缓存技术：将使用频繁的数据放到更高速的存储器中

3. 虚拟内存

    1. 程序不需全部装入即可运行，根据需要动态调整（外存 <-> 内存）
    
    2. 特征：多次性、对换性、虚拟性

    3. 请求调页功能：访问的信息不在内存，由操作系统负责从外存调入内存

    4. 页面置换功能：内存空间不够时，将内存中暂时不用的信息换出到外存

4. 请求分页管理方式

    1. 页表机制：内存块号、状态位、访问字段、修改位、外存地址

    2. 缺页中断机构：访问页面不存在时（属于内中断），产生缺页中断，等待操作系统处理，进程阻塞

    3. 一条指令可能产生多次缺页中断

5. 页面置换算法：追求更少的缺页率

    1. 最佳置换算法：每次选择淘汰最长时间内不再被访问的页面

    2. 先进先出置换算法：淘汰最早进入内存的页面

    3. 最近最久未使用置换算法（LRU）：记录上次被访问时间，性能好、实现困难

    4. 时钟置换算法（CLOCK）（最近未用算法）
        
        1. 为每个页面设置一个访问位
        
        2. 将内存中的页面通过链接指针链接成一个循环队列，选择一个淘汰页面最多经过两轮循环

    5. 改进型的时钟置换算法

        1. 用（访问位、修改位）来表示各页面状态

        2. 最多进行四轮扫描((0, 0) -> (0, 1)访问位置0 -> (0, 0) -> (0, 1))

6. 页面分配策略

    1. 驻留集：指请求分页存储管理中给进程分配的物理块的集合

    2. 固定分配 局部置换
        
        1. 驻留集大小不变

        2. 进程缺页时，从进程中选出页面置换
    
    3. 可变分配 局部置换
        
        1. 驻留集大小可变

        2. 根据缺页率动态增减物理块

    4. 可变分配 全局置换

        1. 驻留集大小可变

        2. 进程缺页时将获得新的物理块，无空闲物理块选择未锁定页面置换

    5. 调入页面 
        
        1. 预调页策略：主要用于进程的首次调入

        2. 请求调页策略：进程在运行期间发现缺页时才将所缺页面调入内存

    6. 抖动（颠簸）现象：进程频繁访问的页面数量高于可用的物理块数

    7. 工作集：指在某段时间间隔里，进程实际访问页面的集合
    
# 4 文件管理

## 4.1 文件管理

1. 文件属性：文件名、标识符、类型、位置、大小、创建时间、修改时间、所有者、保护信息

2. 文件的逻辑结构

    1. 无结构文件（流式文件）

    2. 有结构文件（记录式文件）：有关键字，定长记录、可变长记录

        1. 顺序文件：链式存储，顺序存储：串结构、顺序结构

        2. 索引文件：索引表项顺序存放

        3. 索引顺序文件

        4. 多级索引顺序文件

3. 文件目录

    1. 文件控制块（FCB）：包含文件的基本信息

    2. 目录结构

        1. 单级目录结构：不允许重名

        2. 两级目录结构：主文件目录、用户文件目录

        3. 多级（树形）目录结构：绝对路径、相对路径，不方便文件共享

        4. 无环图目录结构：可以文件共享，整个目录成为一个有向无环图，计数器为0才真正删除结点

    3. 索引结点（改进FCB）：将描述信息存放到索引结点，检索文件时减少I/O次数

4. 文件的物理结构

    1. 文件的逻辑地址空间也被分为一个一个的文件“块”

    2. 文件分配方式

        1. 连续分配：支持顺序访问和直接（随机）访问

        2. 链接分配

            1. 隐式链接：只支持顺序访问

            2. 显式链接：把指针显式地存放在文件分配表（FAT）中，FAT常驻内存，支持随机访问

        3. 索引分配：系统为每个文件建立一张索引表，记录文件的各个逻辑块对应的物理块

            1. 链接方案：将多个索引块链接起来

            2. 多层索引：各层索引表大小不能超过一个磁盘块

            3. 混合索引：包含直接地址索引和间接索引

5. 文件存储空间管理

    1. 空闲表法：记录空闲区间起始位置和长度，回收时可能需要合并表项 

    2. 空闲链表法：记录空闲盘区的长度和指向下一空闲盘区的指针，回收盘块挂到链尾

    3. 位示图：用（字号、位号）对应一个盘块号

    4. 成组链接法：用超级块记录下一组空闲盘块数和空闲块号

6. 文件的基本操作：创建、删除、读、写、打开、关闭

7. 文件共享

    1. 硬链接：基于索引结点，count为0才真正删除文件

    2. 软链接：基于符号链，删除源文件，Link型文件失效

8. 文件保护

    1. 口令保护：口令存在FCB或索引结点中

    2. 加密保护

    3. 访问控制：FCB中增加访问控制列表

## 4.2 磁盘

1. 结构：磁盘、磁道、扇区

2. 磁盘的物理地址：柱面号、盘面号、扇区号

3. 分类：活动头磁盘、固定头磁盘，可换盘磁盘，固定盘磁盘

4. 磁盘调度算法

    1. 寻道时间（受OS影响）、延迟时间（受转速影响）、传输时间（受转速影响）

    2. 先来先服务算法（FCFS）：根据请求访问磁盘的先后顺序进行调度

    3. 最短寻找时间优先（SSTF）：优先处理与当前磁道最近的磁道，可能产生“饥饿”现象

    4. 扫描算法（SCAN）（电梯算法）：磁头在最外才向内移动，在最内才向外移动

    5. LOOK调度算法：在移动方向上没有请求，立即改变磁头的移动方向

    6. 循环扫描算法（C-SCAN）：只有磁道朝某个方向移动时才处理访问请求，返回时直接快速移动到起始端

    7. C-LOOK算法：磁头移动方向上不再有请求时，立即返回到最靠近边缘且需要访问的磁道上

5. 减少磁盘延迟时间：减少磁头的移动

    1. 交替编号

    2. 错位命名

6. 磁盘管理

    1. 磁盘初始化：低级格式化、划分扇区；磁盘分区；逻辑格式化

    2. 引导块：执行初始化程序（自举程序）

    3. 坏块的管理：在FAT表上标明，有“备用扇区”用于替换坏块

# 5 I-O设备管理

## 5.1 

1. 按使用特性分类：人机交互设备、存储设备、网络通信设备

2. 按信息交换的单位分类：块设备、字符设备
    
3. I-O控制器

    1. 功能：接受和识别CPU发出的命令、向CPU报告设备的状态、数据交换、地址识别
 
    2. 组成：CPU与控制器的接口、I-O逻辑、控制器与设备的接口

    3. 寄存器需要有相应的地址

        1. 内存映像I-O：寄存器占用内存地址的一部分

        2. 寄存器独立地址：采用I-O专用地址

4. I-O控制方式

    1. 程序直接控制方式：CPU需要不断地轮询检查，每次读写一个字

    2. 中断驱动方式

    3. DMA方式（直接存储器存取）：传送单位“块”

    4. 通道控制方式：通道是一种硬件，可以识别并执行一些列通道指令，每次读写一组数据块

5. I-O软件层次结构

    1. 用户层软件
    
    2. 设备独立性（无关性）软件：通过“逻辑设备表LUT”来确定对应设备，找到驱动程序
    
    3. 设备驱动程序
    
    4. 中断处理程序：I-O控制器发送中断信号，系统处理
    
    5. 硬件

6. I-O核心子系统

    1. 假脱机技术（SPOOLing技术）

        1. 脱离主机的控制进行的输入、输出操作

        2. 输入井、输出井

        3. 可以将独占式打印机虚拟成共享设备

    2. I-O调度
    
    3. 设备保护
    
    4. 设备分配与回收

        1. 考虑因素：设备的固有属性、设备分配算法、设备分配中的安全性（安全分配方式、不安全分配方式）

        2. 静态分配：进程运行前分配全部资源，结束后归还

        3. 动态分配：进程运行时动态申请

        4. 设备控制表（DCT）：系统为每个设备配置一张DCT，记录设备情况

        5. 控制器控制表（COCT）：操作系统根据COCT的信息对控制器进行操作和管理

        6. 通道控制表（CHCT）：操作系统根据CHCT的信息对通道进行操作和管理

        7. 系统设备表（SDT）：记录系统中全部设备的情况

        8. LUT -> SDT -> DCT -> COCT -> CHCT
    
    5. 缓冲区管理

        1. 作用：缓和CPU和I-O设备速度不匹配的矛盾、减少CPU中断频率、解决数据粒度不匹配的问题、提高并行性

        2. 单缓冲

        3. 双缓冲

        4. 循环缓冲区：将多个大小相等的缓冲区链接成一个循环队列

        5. 缓冲池：空缓冲队列、输入队列、输出队列











