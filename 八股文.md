# C++

1. 在main函数之前和之后可能执行的代码

    执行之前
    
    主要任务：初始化系统相关资源

    1. 设置栈指针

    2. .data段的内容：init static vars, global vars

    3. .bss段的内容：给未初始化的全局变量赋初值

    4. 全局对象初始化，在main之前调用构造函数

    5. 将argc、argv参数传递给main函数

    6. __attribute__((constructor))

    执行之后：

    1. 全局对象的析构函数

    2. __attribute__((destructor))

2. 结构体内存对齐

    1. 结构体内成员按照声明的顺序存储，第一个成员地址和结构体地址相同

    2. 按结构体中size最大的成员对齐

    3. alignas可以指定对齐方式，指定值太小时被忽略

    4. alignof计算类型的对齐方式

    5. 单字节对齐应使用```pragma pack(push, 1);     __attrubute__((packed))```

3. 指针和引用的区别

    |指针|引用|
    |:---:|:---:|
    |变量，存储一个地址|原变量的别名|
    |可以有多级|只有一级|
    |可以为空|定义时必须初始化|
    |可以改变指向|初始化后不可改变|
    |sizeof得到指针的大小|sizeof得到所指向变量的大小|
    |存在指向空值的指针|不存在指向空值的引用|

4. 使用引用还是指针

    1. 需要返回函数内局部变量的内存是用指针，用完记得释放指针。返回局部对象的引用没有意义

    2. 对栈空间敏感时使用引用

    3. 类对象作为参数传递时使用引用

5. 堆和栈

    ||堆|栈|
    |:-:|:-:|:-:|
    |管理方式|自己申请和释放|编译器自动分配|
    |方向|堆向高地址扩展，是不连续的内存区域，大小可以灵活调整|栈顶和栈底是预设好的，栈向（低地址）栈底扩展，大小固定|
    |效率|使用C/C++库函数分配，速度慢，会有碎片（1G-4G）|系统分配，速度快，无碎片（默认4M），底层对栈提供支持，有专门存放栈地址的寄存器和专门的操作指令|
    |管理机制|系统使用链表管理空闲内存地址，申请空间时遍历链表，寻找第一个满足要求的空间|空间充足时系统为程序提供内存，不足时栈溢出|

6. 四种指针

    |int *p[10]|指针数组：包含10个指针|
    |:-:|:-:|
    |int (*p)[10]|数组指针，一个指向含有10个int元素的数组的指针|
    |int *p(int)|p是返回值类型为int*的函数|
    |int (*p)(int)|p是一个函数指针，*p是函数，返回值为int|

# 算法

1. 冒泡排序：小的往前，大的往后

    优化点

    1. 循环n-1次

    2. flag标记是否已经是有序的

# 操作系统

1. 进程、线程和协程的区别和联系

|进程|线程|协程|
|:-:|:-:|:-:|
|资源分配的基本单位|程序执行（调度）的基本单位|线程内部调度的基本单位|
|操作系统负责切换|操作系统负责切换|用户负责切换|
|拥有CPU资源、内存资源、文件资源和句柄等|有程序计数器、寄存器、栈和状态字等资源|有寄存器上下文和栈|
|可用虚拟空间2G|线程栈大小为1M，因此理论上一个进程最多可以创建2048个线程||

2. 外中断和异常：外中断有外部事件引起，如I/O中断，时钟中断，控制台中断等；异常由CPU执行指令的内部事件引起

3. 多线程

    1. 同一进程内部有多个线程，所有的线程共享同一个进程的内存空间

    2. 进程定义的全局变量会被所有的线程共享

    3. 线程依赖关系：线程之间有无先后顺序

    4. 同步互斥问题：多个线程共享访问同一变量

    5. 每个线程有自己独立的栈空间，不能访问其他线程的线程栈

    6. 线程相关接口

        ```cpp
        int pthread_create(pthread_t *pthread, const pthread_attr_t *attr, void(start_routine)(void*), void *agr);
        // pthread用来保存线程的tid
        // start_routine线程执行函数的首地址，传入函数指针
        pthread_t pthread_self();       // 获取线程ID
        int pthread_join(pthread_t tid, void** retval);     // 主线程调用，等待线程退出并回收其资源
        // 创建线程时通过指针得到的tid
        // retval指向返回值的指针
        pthread_exit(void *retval);             // 结束线程
        int pthread_detach(pthread_t tid);      // 分离线程，调用后和主线程分离，子线程 结束时自己立即回收资源
        ```

4. 多进程

    1. 进程 = 代码段 + 堆栈段 + 数据段

    2. 代码段是静态的二进制代码，多个程序可以共享

    3. 父、子进程除pid外，几乎所有部分一样

    4. 父、子进程共享全部数据，但并不是对同一块数据进行操作，子进程在读写数据时会通过写时复制机拷贝公共的数据，然后再拷贝的数据上进行操作

    5. 进程有两种创建方式，一种是操作系统创建的一种是父进程创建的

    6. 相关接口

        ```cpp
        pid_t fork(void);               // 创建进程
        void exit(int status);          // 结束进程
        pid_t getpid(void);             // 获得pid
        pid_t getppid(void);            // 获得父进程pid
        ```
    
    7. exit()和_exit()：exit()是对_exit()的封装，_exit()关闭描述符和清理函数后不会刷新流，exit()调用_exit()前刷新流

    8. return()和exit()：exit()是函数，有参数，执行后将控制权交给系统；return()在函数中时，之后后控制权交给进程，在main()函数中执行后将控制权交给系统

5. Linux进程控制

    1. 进程有两种创建方式，一种是操作系统创建的，一种是父进程创建的

    2. 从0xC0000000开始到0xFFFFFFFF是内核地址空间；0x00000000 ~ 0xC00000000是
用户地址空间

    3. 在内核模式下进程可以访问全部存储器位置和执行全部指令

    4. 进程的调度实际就是内核选择相应的进程控制块，进程控制块中包含了一个进程基本的信
息

    5. 内核管理所有进程控制块，而进程控制块记录了进程全部状态信息

    6. 每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文表）等

    7.  





# 计算机网络

1. OSI七层模型：应用层->(表示层->会话层)->传输层(段）->网络层(包)->数据链路层(帧)->物理层(比特流)

2. 完整的HTTP请求过程

    1. 建立服务器和客户端的连接->客户端向服务端发起请求->服务器收到请求给予响应->客户端解析响应

    2. 发起请求->域名解析->TCP三次握手建立连接->发起HTTP请求->服务器响应HTTP请求->客户端解析响应并渲染结果

3. DNS：域名和IP地址相互映射的一个分布式数据库；属于应用层协议，使用UDP传输

4. DNS工作原理：浏览器缓存->系统缓存(host)->路由器缓存->ISP服务器缓存->根域名服务器缓存->主域名服务器缓存->顶级域名服务器缓存

5. 为什么域名解析用UDP协议？

    1. 速度快，一个请求，一个应答；传输内容一般不超过512字节，UDP传输可以完成

6. 为什么区域传送用TCP协议？

    1. 区域传送：备份DNS从主DNS复制内容

    2. 需要保证可靠性、传输数据量大

7. 短连接和长连接

    1. 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

    2. 从HTTP/1.1起，默认使用长连接，用以保持连接特性

8. TCP粘包/拆包：一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送

    1. 应用程序写入数据的字节大小大于套接字发送缓冲区的大小.

    2. 进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)

    3. 以太网的payload大于MTU进行IP分片

9. 为什么服务器会缓存这一项功能?如何实现的？

    1. 缓解服务器压力

    2. 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并

    3. 实现：让代理服务器进行缓存；让客户端浏览器进行缓存

10. HTTP请求方法

    |方法|描述|
    |:-:|:-:|
    |GET|请求指定的页面信息，并返回实体主体|
    |HEAD|类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头|
    |POST|向指定资源提交数据进行处理请求,POST 请求可能会导致新的资源的建立和/或已有资源的修改|
    |PUT|从客户端向服务器传送的数据取代指定的文档的内容|
    |DELETE|请求服务器删除指定的页面|
    |CONNECT|HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器|
    |OPTIONS|允许客户端查看服务器的性能|
    |TRACE|回显服务器收到的请求，主要用于测试或诊断|
    |PATCH|是对 PUT 方法的补充，用来对已知资源进行局部更新|

11. GET和POST的区别

    1. get是获取数据，post是修改数据

    2. get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body）

    3. get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制

    4. GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)

    5. GET请求会被浏览器主动缓存，而POST不会，除非手动设置

    6. 本质区别：GET是幂等的，而POST不是幂等的（幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果）

    7. 不能用get请求做数据的增删改这些有副作用的操作；因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）

12. 如果维持连接，一个TCP连接可以发送多个HTTP请求

13. 





# 数据库






