# C++

1. 在main函数之前和之后可能执行的代码

    执行之前
    
    主要任务：初始化系统相关资源

    1. 设置栈指针

    2. .data段的内容：init static vars, global vars

    3. .bss段的内容：给未初始化的全局变量赋初值

    4. 全局对象初始化，在main之前调用构造函数

    5. 将argc、argv参数传递给main函数

    6. __attribute__((constructor))

    执行之后：

    1. 全局对象的析构函数

    2. __attribute__((destructor))

2. 结构体内存对齐

    1. 结构体内成员按照声明的顺序存储，第一个成员地址和结构体地址相同

    2. 按结构体中size最大的成员对齐

    3. alignas可以指定对齐方式，指定值太小时被忽略

    4. alignof计算类型的对齐方式

    5. 单字节对齐应使用```pragma pack(push, 1);     __attrubute__((packed))```

3. 指针和引用的区别

    |指针|引用|
    |:---:|:---:|
    |变量，存储一个地址|原变量的别名|
    |可以有多级|只有一级|
    |可以为空|定义时必须初始化|
    |可以改变指向|初始化后不可改变|
    |sizeof得到指针的大小|sizeof得到所指向变量的大小|
    |存在指向空值的指针|不存在指向空值的引用|

4. 使用引用还是指针

    1. 需要返回函数内局部变量的内存是用指针，用完记得释放指针。返回局部对象的引用没有意义

    2. 对栈空间敏感时使用引用

    3. 类对象作为参数传递时使用引用

5. 堆和栈

    ||堆|栈|
    |:-:|:-:|:-:|
    |管理方式|自己申请和释放|编译器自动分配|
    |方向|堆向高地址扩展，是不连续的内存区域，大小可以灵活调整|栈顶和栈底是预设好的，栈向（低地址）栈底扩展，大小固定|
    |效率|使用C/C++库函数分配，速度慢，会有碎片（1G-4G）|系统分配，速度快，无碎片（默认4M），底层对栈提供支持，有专门存放栈地址的寄存器和专门的操作指令|
    |管理机制|系统使用链表管理空闲内存地址，申请空间时遍历链表，寻找第一个满足要求的空间|空间充足时系统为程序提供内存，不足时栈溢出|

6. 四种指针

    |int *p[10]|指针数组：包含10个指针|
    |:-:|:-:|
    |int (*p)[10]|数组指针，一个指向含有10个int元素的数组的指针|
    |int *p(int)|p是返回值类型为int*的函数|
    |int (*p)(int)|p是一个函数指针，*p是函数，返回值为int|

7. new / delete 与 malloc / free的异同

    1. 同：都可用于内存的动态申请和释放

    2. 异：前者是C++运算符；后者是函数，需要库文件支持

    3. new自动计算要分配的空间大小，malloc需要手工计算

    4. new是类型安全的，malloc不是

        ```cpp
        int *p = new float[2];                          //编译错误
        int *p = (int*)malloc(2 * sizeof(double));      //编译无错误
        ```

    5. new封装了malloc，可以直接free，但是直接free不会析构对象

    6. new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者没有相关调用

    7. malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针

    8. 创建非基本数据类型的对象时，需要执行构造函数，销毁需要析构函数，malloc/free不能完成

8. 被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片

9. 宏定义和函数
    
    |宏定义|函数|typedef|
    |:-:|:-:|:-:|
    |在编译前完成替换，相当于直接插入代码|函数调用|编译的一部分|
    |没有返回值|有返回值|
    |没有类型，不进行类型检查|需要检查类型|检查类型|
    |无；|有；|是语句，有；|

10. 变量和声明：声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间；可以多处声明，只能一处定义

11. |sizeof|strlen|
    |:-:|:-:|
    |是运算符，不是函数|字符处理函数|
    |参数可以是任何的数据类型或数据|参数只能是字符指针或结尾为'\0'的字符串|
    |值在编译时确定，所以不能用于动态分配的空间||

12. 指针常量和常量指针

    1. 指针常量：指向常量的指针```int const *p;     const int *p;```(存疑，修改指向的量编译通过；指向的常量应该修饰为const)

    2. 常量指针：一个不能改变指向的指针```int * const p;```

13. 














# 算法

1. 冒泡排序：小的往前，大的往后

    优化点

    1. 循环n-1次

    2. flag标记是否已经是有序的

# 操作系统

1. 进程、线程和协程的区别和联系

|进程|线程|协程|
|:-:|:-:|:-:|
|资源分配的基本单位|程序执行（调度）的基本单位|线程内部调度的基本单位|
|操作系统负责切换|操作系统负责切换|用户负责切换|
|拥有CPU资源、内存资源、文件资源和句柄等|有程序计数器、寄存器、栈和状态字等资源|有寄存器上下文和栈|
|可用虚拟空间2G|线程栈大小为1M，因此理论上一个进程最多可以创建2048个线程||

2. 外中断和异常：外中断有外部事件引起，如I/O中断，时钟中断，控制台中断等；异常由CPU执行指令的内部事件引起

3. 多线程

    1. 同一进程内部有多个线程，所有的线程共享同一个进程的内存空间

    2. 进程定义的全局变量会被所有的线程共享

    3. 线程依赖关系：线程之间有无先后顺序

    4. 同步互斥问题：多个线程共享访问同一变量

    5. 每个线程有自己独立的栈空间，不能访问其他线程的线程栈

    6. 线程相关接口

        ```cpp
        int pthread_create(pthread_t *pthread, const pthread_attr_t *attr, void(start_routine)(void*), void *agr);
        // pthread用来保存线程的tid
        // start_routine线程执行函数的首地址，传入函数指针
        pthread_t pthread_self();       // 获取线程ID
        int pthread_join(pthread_t tid, void** retval);     // 主线程调用，等待线程退出并回收其资源
        // 创建线程时通过指针得到的tid
        // retval指向返回值的指针
        pthread_exit(void *retval);             // 结束线程
        int pthread_detach(pthread_t tid);      // 分离线程，调用后和主线程分离，子线程 结束时自己立即回收资源
        ```

4. 多进程

    1. 进程 = 代码段 + 堆栈段 + 数据段

    2. 代码段是静态的二进制代码，多个程序可以共享

    3. 父、子进程除pid外，几乎所有部分一样

    4. 父、子进程共享全部数据，但并不是对同一块数据进行操作，子进程在读写数据时会通过写时复制机拷贝公共的数据，然后再拷贝的数据上进行操作

    5. 进程有两种创建方式，一种是操作系统创建的一种是父进程创建的

    6. 相关接口

        ```cpp
        pid_t fork(void);               // 创建进程
        void exit(int status);          // 结束进程
        pid_t getpid(void);             // 获得pid
        pid_t getppid(void);            // 获得父进程pid
        ```
    
    7. exit()和_exit()：exit()是对_exit()的封装，_exit()关闭描述符和清理函数后不会刷新流，exit()调用_exit()前刷新流

    8. return()和exit()：exit()是函数，有参数，执行后将控制权交给系统；return()在函数中时，之后后控制权交给进程，在main()函数中执行后将控制权交给系统

5. Linux进程控制

    1. 进程有两种创建方式，一种是操作系统创建的，一种是父进程创建的

    2. 从0xC0000000开始到0xFFFFFFFF是内核地址空间；0x00000000 ~ 0xC00000000是
用户地址空间

    3. 在内核模式下进程可以访问全部存储器位置和执行全部指令

    4. 进程的调度实际就是内核选择相应的进程控制块，进程控制块中包含了一个进程基本的信
息

    5. 内核管理所有进程控制块，而进程控制块记录了进程全部状态信息

    6. 每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文表）等

6. 进程调度算法

    |先来先服务FCFS|非抢占式，按照请求的顺序进行调度；有利于长作业，但不利于短作业|
    |:-:|:-:|
    |短作业优先SJF|非抢占式，按估计运行时间最短的顺序进行调度；长作业有可能会饿死|
    |最短剩余时间优先SRTN|最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度；如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待|
    |时间片轮转|所有就绪进程按 FCFS 的原则排成一个队列，每个进程每次执行一个时间片，未完成则进入队尾；时间片大小影响效率，太小切换频繁，太大实时性差|
    |优先级调度|为每个进程分配一个优先级，按优先级进行调度；可以随着时间的推移增加等待进程的优先级|
    |多级反馈队列|时间片轮转调度+优先级调度;设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列;每个队列优先权也不同，最上面的优先权最高。只有上一个队列没有进程在排队，才能调度当前队列上的进程|

7. Linux下进程间通信方式

    |管道|无名管道（内存文件）：半双工，数据单向流动，只能在父子进程间使用；有名管道（FIFO文件）半双工，先进先出，允许在没有关系的进程间使用|
    |:-:|:-:|
    |共享内存|共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问|
    |消息队列|有消息的链表，存放在内核中并由消息队列标识符标识；克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点|
    |套接字|适用于不同机器间进程通信，在本地也可作为两个进程通信的方式|
    |信号|用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号|
    |信号量|信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问|
 
8. Linux下同步机制

    1. POSIX信号量：可用于进程同步，也可用于线程同步

    2. POSIX互斥锁 + 条件变量：只能用于线程同步

9. 具有快表后，先访问快表，再访问页表（由局部性原理，快表命中率可以达到90%），有的系统支持同时快慢表查找

10. 内存交换和覆盖：交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中

11. 动态分区分配算法

    |算法|思想|分区排列顺序|优点|缺点|
    |:-:|:-:|:-:|:-:|:-:|
    |首次适应|从头到尾找适合的分区|地址递增|综合看性能最好。算法开销小，回收分区后一.般不需要对空闲分区队列重新排序||
    |最佳适应|优先使用更小的分区|容量递增|会有更多的大分区被保留下来，更能满足大进程需求|会产生很多太小的、难以利用的碎片;算法开销大，回收分区后可能需要对空闲分区队列重新排序|
    |最坏适应|优先使用更大的分区|容量递减|可以减少难以利用的小碎片|大分区容易被用完，不利于大进程;算法开销大|
    |临近适应|每次从上次查找结束位置开始查找|地址递增|算法开销小|会使高地址的大分区也被用完|

12. 虚拟技术

    1. 时（时间）分复用技术：：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换
    
    2. 空（空间）分复用技术：虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。






# 计算机网络

1. OSI七层模型：应用层->(表示层->会话层)->传输层(段）->网络层(包)->数据链路层(帧)->物理层(比特流)

2. 完整的HTTP请求过程

    1. 建立服务器和客户端的连接->客户端向服务端发起请求->服务器收到请求给予响应->客户端解析响应

    2. 发起请求->域名解析->TCP三次握手建立连接->发起HTTP请求->服务器响应HTTP请求->客户端解析响应并渲染结果

3. DNS：域名和IP地址相互映射的一个分布式数据库；属于应用层协议，使用UDP传输

4. DNS工作原理：浏览器缓存->系统缓存(host)->路由器缓存->ISP服务器缓存->根域名服务器缓存->顶级域名服务器缓存->主域名服务器缓存

5. 为什么域名解析用UDP协议？

    1. 速度快，一个请求，一个应答；传输内容一般不超过512字节，UDP传输可以完成

6. 为什么区域传送用TCP协议？

    1. 区域传送：备份DNS从主DNS复制内容

    2. 需要保证可靠性、传输数据量大

7. 短连接和长连接

    1. 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

    2. 从HTTP/1.1起，默认使用长连接，用以保持连接特性

8. TCP粘包/拆包：一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送

    1. 应用程序写入数据的字节大小大于套接字发送缓冲区的大小.

    2. 进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)

    3. 以太网的payload大于MTU进行IP分片

9. 为什么服务器会缓存这一项功能?如何实现的？

    1. 缓解服务器压力

    2. 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并

    3. 实现：让代理服务器进行缓存；让客户端浏览器进行缓存

10. HTTP请求方法

    |方法|描述|
    |:-:|:-:|
    |GET|请求指定的页面信息，并返回实体主体|
    |HEAD|类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头|
    |POST|向指定资源提交数据进行处理请求,POST 请求可能会导致新的资源的建立和/或已有资源的修改|
    |PUT|从客户端向服务器传送的数据取代指定的文档的内容|
    |DELETE|请求服务器删除指定的页面|
    |CONNECT|HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器|
    |OPTIONS|允许客户端查看服务器的性能|
    |TRACE|回显服务器收到的请求，主要用于测试或诊断|
    |PATCH|是对 PUT 方法的补充，用来对已知资源进行局部更新|

11. GET和POST的区别

    1. get是获取数据，post是修改数据

    2. get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body）

    3. get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制

    4. GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)

    5. GET请求会被浏览器主动缓存，而POST不会，除非手动设置

    6. 本质区别：GET是幂等的，而POST不是幂等的（幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果）

    7. 不能用get请求做数据的增删改这些有副作用的操作；因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）

12. 如果维持连接，一个TCP连接可以发送多个HTTP请求

13. 单个TCP连接在同一时刻只能处理一个请求，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里不能重叠

14. 浏览器是如何提高页面加载效率的呢？

    维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求；和服务器建立多个TCP连接

15. Chrome最多允许对同一个Host建立六个TCP连接。不同的浏览器有一些区别

16. 在浏览器中输入url地址后显示主页的过程

    1. 根据域名，进行DNS域名解析->通过IP地址建立TCP连接->发送HTTP请求->服务器处理请求->返回响应结果->关闭TCP连接->浏览器解析HTML->浏览器布局渲染

    2. 技术步骤：查浏览器缓存->查本地hosts->gethostbyname->（如果在一个子网内，采用ARP地址解析协议进行ARP查询，不在一个子网则对默认网关进行DNS查询）->根DNS服务器->得到IP地址后三次握手建立TCP连接（http：80，https：443）->四次挥手->再次传输，重新建立连接，使用SSL加密传输数据->浏览器使用ajax等技术渲染网页

17. DNS负载均衡：在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的

18. HTTP和HTTPS

    |HTTP|HTTPS|
    |:-:|:-:|
    |传输的数据都是未加密的|由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议|
    ||https协议需要到ca申请证书|
    |Port:80|Port:443|

19. 

# 数据库






